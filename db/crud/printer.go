// Code generated by SQLBoiler 4.2.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package crud

import (
	"database/sql"
	"fmt"
	"net/http"
	"strings"

	"github.com/friendsofgo/errors"
	"github.com/gorilla/mux"
	"github.com/korylprince/httputil/jsonapi"
	"github.com/korylprince/printer-manager/db"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
)

func CreatePrinter(r *http.Request, tx *sql.Tx) (int, interface{}) {
	vars := mux.Vars(r)

	printer := new(db.Printer)
	if err := jsonapi.ParseJSONBody(r, printer); err != nil {
		return http.StatusBadRequest, err
	}

	if fid := vars[db.PrinterColumns.LocationID]; fid != "" {
		vars[db.PrinterColumns.ID] = fid
		delete(vars, db.PrinterColumns.LocationID)
		code, location := ReadLocation(r, tx)
		if err, ok := location.(error); ok {
			return code, err
		}
		printer.LocationID = fid

	} else if fid := vars[db.PrinterColumns.ModelID]; fid != "" {
		vars[db.PrinterColumns.ID] = fid
		delete(vars, db.PrinterColumns.ModelID)
		code, model := ReadModel(r, tx)
		if err, ok := model.(error); ok {
			return code, err
		}
		printer.ModelID = fid
	}

	if err := printer.Insert(r.Context(), tx, boil.Blacklist(
		db.PrinterColumns.ID,
	)); err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates") {
			return http.StatusConflict, fmt.Errorf("Unable to insert duplicate Printer: %v", err)
		} else if strings.Contains(err.Error(), "value too long for type character varying") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Printer: %v", err)
		} else if strings.Contains(err.Error(), "violates check constraint") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Printer: %v", err)
		} else if strings.Contains(err.Error(), "invalid input syntax for type uuid") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Printer: %v", err)
		} else if strings.Contains(err.Error(), "violates foreign key constraint") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Printer: %v", err)
		}
		return http.StatusInternalServerError, fmt.Errorf("Unable to insert Printer: %v", err)
	}

	return http.StatusOK, printer
}

func ReadPrinter(r *http.Request, tx *sql.Tx) (int, interface{}) {
	vars := mux.Vars(r)
	id := vars[db.PrinterColumns.ID]

	var (
		printer *db.Printer
		err     error
	)

	if fid := vars[db.PrinterColumns.LocationID]; fid != "" {
		vars[db.PrinterColumns.ID] = fid
		delete(vars, db.PrinterColumns.LocationID)
		code, location := ReadLocation(r, tx)
		if err, ok := location.(error); ok {
			return code, err
		}
		printer, err = (location.(*db.Location)).Printers(qm.Where("id = ?", id)).One(r.Context(), tx)

	} else if fid := vars[db.PrinterColumns.ModelID]; fid != "" {
		vars[db.PrinterColumns.ID] = fid
		delete(vars, db.PrinterColumns.ModelID)
		code, model := ReadModel(r, tx)
		if err, ok := model.(error); ok {
			return code, err
		}
		printer, err = (model.(*db.Model)).Printers(qm.Where("id = ?", id)).One(r.Context(), tx)

	} else {
		printer, err = db.FindPrinter(r.Context(), tx, id)
	}

	if err != nil {
		if strings.Contains(err.Error(), "no rows in result set") {
			return http.StatusNotFound, fmt.Errorf("Printer %s does not exist", id)
		}

		return http.StatusInternalServerError, fmt.Errorf("Unable to find Printer %s: %v", id, err)
	}

	return http.StatusOK, printer
}

func UpdatePrinter(r *http.Request, tx *sql.Tx) (int, interface{}) {
	vars := mux.Vars(r)
	id := vars[db.PrinterColumns.ID]

	newPrinter := new(db.Printer)
	if err := jsonapi.ParseJSONBody(r, newPrinter); err != nil {
		return http.StatusBadRequest, err
	}

	var (
		printer *db.Printer
		err     error
	)

	if fid := vars[db.PrinterColumns.LocationID]; fid != "" {
		vars[db.PrinterColumns.ID] = fid
		delete(vars, db.PrinterColumns.LocationID)
		code, location := ReadLocation(r, tx)
		if err, ok := location.(error); ok {
			return code, err
		}
		printer, err = (location.(*db.Location)).Printers(qm.Where("id = ?", id)).One(r.Context(), tx)

	} else if fid := vars[db.PrinterColumns.ModelID]; fid != "" {
		vars[db.PrinterColumns.ID] = fid
		delete(vars, db.PrinterColumns.ModelID)
		code, model := ReadModel(r, tx)
		if err, ok := model.(error); ok {
			return code, err
		}
		printer, err = (model.(*db.Model)).Printers(qm.Where("id = ?", id)).One(r.Context(), tx)

	} else {
		printer, err = db.FindPrinter(r.Context(), tx, id)
	}

	if err != nil {
		if strings.Contains(err.Error(), "no rows in result set") {
			return http.StatusNotFound, fmt.Errorf("Printer %s does not exist", id)
		}

		return http.StatusInternalServerError, fmt.Errorf("Unable to find Printer %s: %v", id, err)
	}

	if newPrinter.ModelID != "" {
		printer.ModelID = newPrinter.ModelID
	} else if fid := vars[db.PrinterColumns.ModelID]; fid != "" {
		printer.ModelID = fid
	}
	if newPrinter.LocationID != "" {
		printer.LocationID = newPrinter.LocationID
	} else if fid := vars[db.PrinterColumns.LocationID]; fid != "" {
		printer.LocationID = fid
	}
	printer.Hostname = newPrinter.Hostname

	printer.DriverExtra = newPrinter.DriverExtra

	if _, err = printer.Update(r.Context(), tx, boil.Blacklist(
		db.PrinterColumns.ID,
	)); err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates") {
			return http.StatusConflict, fmt.Errorf("Unable to insert duplicate Printer: %v", err)
		} else if strings.Contains(err.Error(), "value too long for type character varying") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Printer: %v", err)
		} else if strings.Contains(err.Error(), "violates check constraint") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Printer: %v", err)
		} else if strings.Contains(err.Error(), "invalid input syntax for type uuid") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Printer: %v", err)
		} else if strings.Contains(err.Error(), "violates foreign key constraint") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Printer: %v", err)
		}
		return http.StatusInternalServerError, fmt.Errorf("Unable to insert Printer: %v", err)
	}

	return http.StatusOK, printer
}

func DeletePrinter(r *http.Request, tx *sql.Tx) (int, interface{}) {
	vars := mux.Vars(r)
	id := vars[db.PrinterColumns.ID]

	var (
		printer *db.Printer
		err     error
	)

	if fid := vars[db.PrinterColumns.LocationID]; fid != "" {
		vars[db.PrinterColumns.ID] = fid
		delete(vars, db.PrinterColumns.LocationID)
		code, location := ReadLocation(r, tx)
		if err, ok := location.(error); ok {
			return code, err
		}
		printer, err = (location.(*db.Location)).Printers(qm.Where("id = ?", id)).One(r.Context(), tx)

	} else if fid := vars[db.PrinterColumns.ModelID]; fid != "" {
		vars[db.PrinterColumns.ID] = fid
		delete(vars, db.PrinterColumns.ModelID)
		code, model := ReadModel(r, tx)
		if err, ok := model.(error); ok {
			return code, err
		}
		printer, err = (model.(*db.Model)).Printers(qm.Where("id = ?", id)).One(r.Context(), tx)

	} else {
		printer, err = db.FindPrinter(r.Context(), tx, id)
	}

	if err != nil {
		if strings.Contains(err.Error(), "no rows in result set") {
			return http.StatusNotFound, fmt.Errorf("Printer %s does not exist", id)
		}

		return http.StatusInternalServerError, fmt.Errorf("Unable to find Printer %s: %v", id, err)
	}

	if _, err = printer.Delete(r.Context(), tx); err != nil {
		return http.StatusInternalServerError, fmt.Errorf("Unable to delete Printer %s: %v", id, err)
	}

	return http.StatusOK, nil
}

func QueryPrinters(r *http.Request, tx *sql.Tx) (int, interface{}) {
	params := r.URL.Query()
	vars := mux.Vars(r)
	var mods []qm.QueryMod

	if fid := vars[db.PrinterColumns.LocationID]; fid != "" {
		vars[db.PrinterColumns.ID] = fid
		delete(vars, db.PrinterColumns.LocationID)
		code, location := ReadLocation(r, tx)
		if err, ok := location.(error); ok {
			return code, err
		}
		vars[db.PrinterColumns.LocationID] = fid
		mods = append(mods, qm.Where("location_id = ?", fid))
	} else if fid := vars[db.PrinterColumns.ModelID]; fid != "" {
		vars[db.PrinterColumns.ID] = fid
		delete(vars, db.PrinterColumns.ModelID)
		code, model := ReadModel(r, tx)
		if err, ok := model.(error); ok {
			return code, err
		}
		vars[db.PrinterColumns.ModelID] = fid
		mods = append(mods, qm.Where("model_id = ?", fid))
	}

	if _, ok := params[db.PrinterColumns.LocationID]; ok {
		if _, ok := vars[db.PrinterColumns.LocationID]; !ok {
			mods = append(mods, qm.Where("location_id = ?", params.Get(db.PrinterColumns.LocationID)))
		}
	}

	if _, ok := params[db.PrinterColumns.ModelID]; ok {
		if _, ok := vars[db.PrinterColumns.ModelID]; !ok {
			mods = append(mods, qm.Where("model_id = ?", params.Get(db.PrinterColumns.ModelID)))
		}
	}

	if _, ok := params[db.PrinterColumns.Hostname]; ok {
		mods = append(mods, qm.Where("hostname LIKE ?", params.Get(db.PrinterColumns.Hostname)))
	}
	if _, ok := params[db.PrinterColumns.DriverExtra]; ok {
		mods = append(mods, qm.Where("driver_extra = ?", params.Get(db.PrinterColumns.DriverExtra)))
	}

	printers, err := db.Printers(mods...).All(r.Context(), tx)
	if err != nil {
		if strings.Contains(err.Error(), "no rows in result set") {
			return http.StatusNotFound, errors.New("No Printers found matching query")
		}

		return http.StatusInternalServerError, fmt.Errorf("Unable to query Printers: %v", err)
	}

	if printers == nil {
		return http.StatusOK, db.PrinterSlice{}
	}

	return http.StatusOK, printers
}
