// Code generated by SQLBoiler 4.2.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package crud

import (
	"database/sql"
	"fmt"
	"net/http"
	"strings"

	"github.com/friendsofgo/errors"
	"github.com/gorilla/mux"
	"github.com/korylprince/httputil/jsonapi"
	"github.com/korylprince/printer-manager/db"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
)

func CreateLocation(r *http.Request, tx *sql.Tx) (int, interface{}) {
	vars := mux.Vars(r)

	location := new(db.Location)
	if err := jsonapi.ParseJSONBody(r, location); err != nil {
		return http.StatusBadRequest, err
	}

	if fid := vars[db.LocationColumns.BuildingID]; fid != "" {
		vars[db.LocationColumns.ID] = fid
		delete(vars, db.LocationColumns.BuildingID)
		code, building := ReadBuilding(r, tx)
		if err, ok := building.(error); ok {
			return code, err
		}
		location.BuildingID = fid
	}

	if err := location.Insert(r.Context(), tx, boil.Blacklist(
		db.LocationColumns.ID,
	)); err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates") {
			return http.StatusConflict, fmt.Errorf("Unable to insert duplicate Location: %v", err)
		} else if strings.Contains(err.Error(), "value too long for type character varying") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Location: %v", err)
		} else if strings.Contains(err.Error(), "violates check constraint") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Location: %v", err)
		} else if strings.Contains(err.Error(), "invalid input syntax for type uuid") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Location: %v", err)
		} else if strings.Contains(err.Error(), "violates foreign key constraint") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Location: %v", err)
		}
		return http.StatusInternalServerError, fmt.Errorf("Unable to insert Location: %v", err)
	}

	return http.StatusOK, location
}

func ReadLocation(r *http.Request, tx *sql.Tx) (int, interface{}) {
	vars := mux.Vars(r)
	id := vars[db.LocationColumns.ID]

	var (
		location *db.Location
		err      error
	)

	if fid := vars[db.LocationColumns.BuildingID]; fid != "" {
		vars[db.LocationColumns.ID] = fid
		delete(vars, db.LocationColumns.BuildingID)
		code, building := ReadBuilding(r, tx)
		if err, ok := building.(error); ok {
			return code, err
		}
		location, err = (building.(*db.Building)).Locations(qm.Where("id = ?", id)).One(r.Context(), tx)

	} else {
		location, err = db.FindLocation(r.Context(), tx, id)
	}

	if err != nil {
		if strings.Contains(err.Error(), "no rows in result set") {
			return http.StatusNotFound, fmt.Errorf("Location %s does not exist", id)
		}

		return http.StatusInternalServerError, fmt.Errorf("Unable to find Location %s: %v", id, err)
	}

	return http.StatusOK, location
}

func UpdateLocation(r *http.Request, tx *sql.Tx) (int, interface{}) {
	vars := mux.Vars(r)
	id := vars[db.LocationColumns.ID]

	newLocation := new(db.Location)
	if err := jsonapi.ParseJSONBody(r, newLocation); err != nil {
		return http.StatusBadRequest, err
	}

	var (
		location *db.Location
		err      error
	)

	if fid := vars[db.LocationColumns.BuildingID]; fid != "" {
		vars[db.LocationColumns.ID] = fid
		delete(vars, db.LocationColumns.BuildingID)
		code, building := ReadBuilding(r, tx)
		if err, ok := building.(error); ok {
			return code, err
		}
		location, err = (building.(*db.Building)).Locations(qm.Where("id = ?", id)).One(r.Context(), tx)

	} else {
		location, err = db.FindLocation(r.Context(), tx, id)
	}

	if err != nil {
		if strings.Contains(err.Error(), "no rows in result set") {
			return http.StatusNotFound, fmt.Errorf("Location %s does not exist", id)
		}

		return http.StatusInternalServerError, fmt.Errorf("Unable to find Location %s: %v", id, err)
	}

	if newLocation.BuildingID != "" {
		location.BuildingID = newLocation.BuildingID
	} else if fid := vars[db.LocationColumns.BuildingID]; fid != "" {
		location.BuildingID = fid
	}
	location.Name = newLocation.Name

	if _, err = location.Update(r.Context(), tx, boil.Blacklist(
		db.LocationColumns.ID,
	)); err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates") {
			return http.StatusConflict, fmt.Errorf("Unable to insert duplicate Location: %v", err)
		} else if strings.Contains(err.Error(), "value too long for type character varying") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Location: %v", err)
		} else if strings.Contains(err.Error(), "violates check constraint") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Location: %v", err)
		} else if strings.Contains(err.Error(), "invalid input syntax for type uuid") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Location: %v", err)
		} else if strings.Contains(err.Error(), "violates foreign key constraint") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Location: %v", err)
		}
		return http.StatusInternalServerError, fmt.Errorf("Unable to insert Location: %v", err)
	}

	return http.StatusOK, location
}

func DeleteLocation(r *http.Request, tx *sql.Tx) (int, interface{}) {
	vars := mux.Vars(r)
	id := vars[db.LocationColumns.ID]

	var (
		location *db.Location
		err      error
	)

	if fid := vars[db.LocationColumns.BuildingID]; fid != "" {
		vars[db.LocationColumns.ID] = fid
		delete(vars, db.LocationColumns.BuildingID)
		code, building := ReadBuilding(r, tx)
		if err, ok := building.(error); ok {
			return code, err
		}
		location, err = (building.(*db.Building)).Locations(qm.Where("id = ?", id)).One(r.Context(), tx)

	} else {
		location, err = db.FindLocation(r.Context(), tx, id)
	}

	if err != nil {
		if strings.Contains(err.Error(), "no rows in result set") {
			return http.StatusNotFound, fmt.Errorf("Location %s does not exist", id)
		}

		return http.StatusInternalServerError, fmt.Errorf("Unable to find Location %s: %v", id, err)
	}

	groups, err := location.Groups().All(r.Context(), tx)
	if err != nil {
		return http.StatusInternalServerError, fmt.Errorf("Unable to find Location %s Groups: %v", id, err)
	}
	if len(groups) > 0 {
		return http.StatusConflict, fmt.Errorf("Location %s still in use", id)
	}

	users, err := location.Users().All(r.Context(), tx)
	if err != nil {
		return http.StatusInternalServerError, fmt.Errorf("Unable to find Location %s Users: %v", id, err)
	}
	if len(users) > 0 {
		return http.StatusConflict, fmt.Errorf("Location %s still in use", id)
	}

	printers, err := location.Printers().All(r.Context(), tx)
	if err != nil {
		return http.StatusInternalServerError, fmt.Errorf("Unable to find Location %s Printers: %v", id, err)
	}
	if len(printers) > 0 {
		return http.StatusConflict, fmt.Errorf("Location %s still in use", id)
	}

	if _, err = location.Delete(r.Context(), tx); err != nil {
		return http.StatusInternalServerError, fmt.Errorf("Unable to delete Location %s: %v", id, err)
	}

	return http.StatusOK, nil
}

func QueryLocations(r *http.Request, tx *sql.Tx) (int, interface{}) {
	params := r.URL.Query()
	vars := mux.Vars(r)
	var mods []qm.QueryMod

	if fid := vars[db.LocationColumns.BuildingID]; fid != "" {
		vars[db.LocationColumns.ID] = fid
		delete(vars, db.LocationColumns.BuildingID)
		code, building := ReadBuilding(r, tx)
		if err, ok := building.(error); ok {
			return code, err
		}
		vars[db.LocationColumns.BuildingID] = fid
		mods = append(mods, qm.Where("building_id = ?", fid))
	}

	if _, ok := params[db.LocationColumns.BuildingID]; ok {
		if _, ok := vars[db.LocationColumns.BuildingID]; !ok {
			mods = append(mods, qm.Where("building_id = ?", params.Get(db.LocationColumns.BuildingID)))
		}
	}

	if _, ok := params[db.LocationColumns.Name]; ok {
		mods = append(mods, qm.Where("name LIKE ?", params.Get(db.LocationColumns.Name)))
	}

	locations, err := db.Locations(mods...).All(r.Context(), tx)
	if err != nil {
		if strings.Contains(err.Error(), "no rows in result set") {
			return http.StatusNotFound, errors.New("No Locations found matching query")
		}

		return http.StatusInternalServerError, fmt.Errorf("Unable to query Locations: %v", err)
	}

	if locations == nil {
		return http.StatusOK, db.LocationSlice{}
	}

	return http.StatusOK, locations
}

func RelateLocationGroup(r *http.Request, tx *sql.Tx) (int, interface{}) {
	vars := mux.Vars(r)

	vars[db.LocationColumns.ID] = vars["location_id"]
	delete(vars, "location_id")
	code, v := ReadLocation(r, tx)
	if err, ok := v.(error); ok {
		return code, err
	}
	location := v.(*db.Location)

	vars[db.LocationColumns.ID] = vars["group_id"]
	delete(vars, "group_id")
	code, v = ReadGroup(r, tx)
	if err, ok := v.(error); ok {
		return code, err
	}
	group := v.(*db.Group)

	ok, err := location.Groups(qm.Where("id = ?", group.ID)).Exists(r.Context(), tx)
	if err != nil {
		return http.StatusInternalServerError, fmt.Errorf("Unable to check if Location related to Group: %v", err)
	}
	if ok {
		return http.StatusOK, nil
	}

	if err := location.AddGroups(r.Context(), tx, false, group); err != nil {
		return http.StatusInternalServerError, fmt.Errorf("Unable to relate Location to Group: %v", err)
	}

	return http.StatusOK, nil
}

func UnrelateLocationGroup(r *http.Request, tx *sql.Tx) (int, interface{}) {
	vars := mux.Vars(r)

	vars[db.LocationColumns.ID] = vars["location_id"]
	delete(vars, "location_id")
	code, v := ReadLocation(r, tx)
	if err, ok := v.(error); ok {
		return code, err
	}
	location := v.(*db.Location)

	vars[db.LocationColumns.ID] = vars["group_id"]
	delete(vars, "group_id")
	code, v = ReadGroup(r, tx)
	if err, ok := v.(error); ok {
		return code, err
	}
	group := v.(*db.Group)

	ok, err := location.Groups(qm.Where("id = ?", group.ID)).Exists(r.Context(), tx)
	if err != nil {
		return http.StatusInternalServerError, fmt.Errorf("Unable to check if Location related to Group: %v", err)
	}
	if !ok {
		return http.StatusOK, nil
	}

	if err := location.RemoveGroups(r.Context(), tx, group); err != nil {
		return http.StatusInternalServerError, fmt.Errorf("Unable to unrelate Location to Group: %v", err)
	}

	return http.StatusOK, nil
}

func ReadLocationGroups(r *http.Request, tx *sql.Tx) (int, interface{}) {
	vars := mux.Vars(r)

	vars[db.LocationColumns.ID] = vars["location_id"]
	delete(vars, "location_id")
	code, v := ReadLocation(r, tx)
	if err, ok := v.(error); ok {
		return code, err
	}
	location := v.(*db.Location)

	groups, err := location.Groups().All(r.Context(), tx)
	if err != nil {
		return http.StatusInternalServerError, fmt.Errorf("Unable to read Location Groups: %v", err)
	}

	if groups == nil {
		return http.StatusOK, db.GroupSlice{}
	}

	return http.StatusOK, groups
}

func RelateLocationUser(r *http.Request, tx *sql.Tx) (int, interface{}) {
	vars := mux.Vars(r)

	vars[db.LocationColumns.ID] = vars["location_id"]
	delete(vars, "location_id")
	code, v := ReadLocation(r, tx)
	if err, ok := v.(error); ok {
		return code, err
	}
	location := v.(*db.Location)

	vars[db.LocationColumns.ID] = vars["user_id"]
	delete(vars, "user_id")
	code, v = ReadUser(r, tx)
	if err, ok := v.(error); ok {
		return code, err
	}
	user := v.(*db.User)

	ok, err := location.Users(qm.Where("id = ?", user.ID)).Exists(r.Context(), tx)
	if err != nil {
		return http.StatusInternalServerError, fmt.Errorf("Unable to check if Location related to User: %v", err)
	}
	if ok {
		return http.StatusOK, nil
	}

	if err := location.AddUsers(r.Context(), tx, false, user); err != nil {
		return http.StatusInternalServerError, fmt.Errorf("Unable to relate Location to User: %v", err)
	}

	return http.StatusOK, nil
}

func UnrelateLocationUser(r *http.Request, tx *sql.Tx) (int, interface{}) {
	vars := mux.Vars(r)

	vars[db.LocationColumns.ID] = vars["location_id"]
	delete(vars, "location_id")
	code, v := ReadLocation(r, tx)
	if err, ok := v.(error); ok {
		return code, err
	}
	location := v.(*db.Location)

	vars[db.LocationColumns.ID] = vars["user_id"]
	delete(vars, "user_id")
	code, v = ReadUser(r, tx)
	if err, ok := v.(error); ok {
		return code, err
	}
	user := v.(*db.User)

	ok, err := location.Users(qm.Where("id = ?", user.ID)).Exists(r.Context(), tx)
	if err != nil {
		return http.StatusInternalServerError, fmt.Errorf("Unable to check if Location related to User: %v", err)
	}
	if !ok {
		return http.StatusOK, nil
	}

	if err := location.RemoveUsers(r.Context(), tx, user); err != nil {
		return http.StatusInternalServerError, fmt.Errorf("Unable to unrelate Location to User: %v", err)
	}

	return http.StatusOK, nil
}

func ReadLocationUsers(r *http.Request, tx *sql.Tx) (int, interface{}) {
	vars := mux.Vars(r)

	vars[db.LocationColumns.ID] = vars["location_id"]
	delete(vars, "location_id")
	code, v := ReadLocation(r, tx)
	if err, ok := v.(error); ok {
		return code, err
	}
	location := v.(*db.Location)

	users, err := location.Users().All(r.Context(), tx)
	if err != nil {
		return http.StatusInternalServerError, fmt.Errorf("Unable to read Location Users: %v", err)
	}

	if users == nil {
		return http.StatusOK, db.UserSlice{}
	}

	return http.StatusOK, users
}
