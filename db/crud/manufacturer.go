// Code generated by SQLBoiler 4.2.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package crud

import (
	"database/sql"
	"fmt"
	"net/http"
	"strings"

	"github.com/friendsofgo/errors"
	"github.com/gorilla/mux"
	"github.com/korylprince/httputil/jsonapi"
	"github.com/korylprince/printer-manager/db"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
)

func CreateManufacturer(r *http.Request, tx *sql.Tx) (int, interface{}) {
	manufacturer := new(db.Manufacturer)
	if err := jsonapi.ParseJSONBody(r, manufacturer); err != nil {
		return http.StatusBadRequest, err
	}

	if err := manufacturer.Insert(r.Context(), tx, boil.Blacklist(
		db.ManufacturerColumns.ID,
	)); err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates") {
			return http.StatusConflict, fmt.Errorf("Unable to insert duplicate Manufacturer: %v", err)
		} else if strings.Contains(err.Error(), "value too long for type character varying") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Manufacturer: %v", err)
		} else if strings.Contains(err.Error(), "violates check constraint") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Manufacturer: %v", err)
		} else if strings.Contains(err.Error(), "invalid input syntax for type uuid") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Manufacturer: %v", err)
		} else if strings.Contains(err.Error(), "violates foreign key constraint") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Manufacturer: %v", err)
		}
		return http.StatusInternalServerError, fmt.Errorf("Unable to insert Manufacturer: %v", err)
	}

	return http.StatusOK, manufacturer
}

func ReadManufacturer(r *http.Request, tx *sql.Tx) (int, interface{}) {
	vars := mux.Vars(r)
	id := vars[db.ManufacturerColumns.ID]

	manufacturer, err := db.FindManufacturer(r.Context(), tx, id)
	if err != nil {
		if strings.Contains(err.Error(), "no rows in result set") {
			return http.StatusNotFound, fmt.Errorf("Manufacturer %s does not exist", id)
		}

		return http.StatusInternalServerError, fmt.Errorf("Unable to find Manufacturer %s: %v", id, err)
	}

	return http.StatusOK, manufacturer
}

func UpdateManufacturer(r *http.Request, tx *sql.Tx) (int, interface{}) {
	vars := mux.Vars(r)
	id := vars[db.ManufacturerColumns.ID]

	newManufacturer := new(db.Manufacturer)
	if err := jsonapi.ParseJSONBody(r, newManufacturer); err != nil {
		return http.StatusBadRequest, err
	}

	manufacturer, err := db.FindManufacturer(r.Context(), tx, id)
	if err != nil {
		if strings.Contains(err.Error(), "no rows in result set") {
			return http.StatusNotFound, fmt.Errorf("Manufacturer %s does not exist", id)
		}

		return http.StatusInternalServerError, fmt.Errorf("Unable to find Manufacturer %s: %v", id, err)
	}

	manufacturer.Name = newManufacturer.Name

	if _, err = manufacturer.Update(r.Context(), tx, boil.Blacklist(
		db.ManufacturerColumns.ID,
	)); err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates") {
			return http.StatusConflict, fmt.Errorf("Unable to insert duplicate Manufacturer: %v", err)
		} else if strings.Contains(err.Error(), "value too long for type character varying") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Manufacturer: %v", err)
		} else if strings.Contains(err.Error(), "violates check constraint") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Manufacturer: %v", err)
		} else if strings.Contains(err.Error(), "invalid input syntax for type uuid") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Manufacturer: %v", err)
		} else if strings.Contains(err.Error(), "violates foreign key constraint") {
			return http.StatusBadRequest, fmt.Errorf("Unable to insert invalid Manufacturer: %v", err)
		}
		return http.StatusInternalServerError, fmt.Errorf("Unable to insert Manufacturer: %v", err)
	}

	return http.StatusOK, manufacturer
}

func DeleteManufacturer(r *http.Request, tx *sql.Tx) (int, interface{}) {
	vars := mux.Vars(r)
	id := vars[db.ManufacturerColumns.ID]

	manufacturer, err := db.FindManufacturer(r.Context(), tx, id)
	if err != nil {
		if strings.Contains(err.Error(), "no rows in result set") {
			return http.StatusNotFound, fmt.Errorf("Manufacturer %s does not exist", id)
		}

		return http.StatusInternalServerError, fmt.Errorf("Unable to find Manufacturer %s: %v", id, err)
	}

	models, err := manufacturer.Models().All(r.Context(), tx)
	if err != nil {
		return http.StatusInternalServerError, fmt.Errorf("Unable to find Manufacturer %s Models: %v", id, err)
	}
	if len(models) > 0 {
		return http.StatusConflict, fmt.Errorf("Manufacturer %s still in use", id)
	}

	if _, err = manufacturer.Delete(r.Context(), tx); err != nil {
		return http.StatusInternalServerError, fmt.Errorf("Unable to delete Manufacturer %s: %v", id, err)
	}

	return http.StatusOK, nil
}

func QueryManufacturers(r *http.Request, tx *sql.Tx) (int, interface{}) {
	params := r.URL.Query()
	var mods []qm.QueryMod

	if _, ok := params[db.ManufacturerColumns.Name]; ok {
		mods = append(mods, qm.Where("name LIKE ?", params.Get(db.ManufacturerColumns.Name)))
	}

	manufacturers, err := db.Manufacturers(mods...).All(r.Context(), tx)
	if err != nil {
		if strings.Contains(err.Error(), "no rows in result set") {
			return http.StatusNotFound, errors.New("No Manufacturers found matching query")
		}

		return http.StatusInternalServerError, fmt.Errorf("Unable to query Manufacturers: %v", err)
	}

	if manufacturers == nil {
		return http.StatusOK, db.ManufacturerSlice{}
	}

	return http.StatusOK, manufacturers
}
